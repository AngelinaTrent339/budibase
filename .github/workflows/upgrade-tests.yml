name: Upgrade Tests

on:
  pull_request:
    paths-ignore:
      - "docs/**"
      - "README.md"
      - ".github/workflows/!(upgrade-tests.yml)"
  workflow_dispatch:

env:
  INTERNAL_API_KEY: budibase

# Cancel in-progress runs when a new run is triggered
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  get-test-config:
    runs-on: ubuntu-latest
    outputs:
      versions: ${{ steps.versions.outputs.versions }}
      apps: ${{ steps.apps.outputs.apps }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            packages/upgrade-tests/src/fixtures
      
      - name: Get available test apps
        id: apps
        run: |
          # Find all .tar.gz files in fixtures and extract app names
          cd packages/upgrade-tests/src/fixtures
          APPS=$(ls *.tar.gz 2>/dev/null | sed 's/\.tar\.gz$//' | jq -R . | jq -s . || echo '[]')
          
          # If no apps found, create array with special "no-apps" marker
          if [ "$APPS" = "[]" ]; then
            APPS='["no-apps"]'
          fi
          
          echo "apps=$APPS" >> $GITHUB_OUTPUT
          echo "Found test apps: $APPS"
      
      - name: Get versions to test
        id: versions
        run: |
          # Fetch last 5 minor versions from Docker Hub
          # Using Docker Hub API to get tags
          RESPONSE=$(curl -s "https://hub.docker.com/v2/repositories/budibase/budibase/tags?page_size=100")
          
          # Extract version tags (excluding latest, develop, etc)
          VERSIONS=$(echo "$RESPONSE" | jq -r '
            .results 
            | map(select(.name | test("^[0-9]+\\.[0-9]+\\.[0-9]+$"))) 
            | map(.name) 
            | map(split(".") | {major: .[0] | tonumber, minor: .[1] | tonumber, patch: .[2] | tonumber, version: .}) 
            | group_by(.major + "." + (.minor | tostring)) 
            | map(max_by(.patch)) 
            | sort_by(.major, .minor) 
            | reverse 
            | .[0:5] 
            | map(.version | join("."))
          ')

          echo "versions=$VERSIONS" >> $GITHUB_OUTPUT
          echo "Testing versions: $VERSIONS"

  test-upgrade:
    needs: get-test-config
    if: needs.get-test-config.outputs.apps != '["no-apps"]'
    strategy:
      fail-fast: false
      matrix:
        version: ${{ fromJson(needs.get-test-config.outputs.versions) }}
        app: ${{ fromJson(needs.get-test-config.outputs.apps) }}
    runs-on: ubuntu-latest
    name: Test ${{ matrix.version }} - ${{ matrix.app }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: yarn
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Install dependencies
        run: |
          cd packages/upgrade-tests
          yarn install --frozen-lockfile

      - name: Build upgrade tests
        run: |
          cd packages/upgrade-tests
          yarn build

      # CouchDB and MinIO are included in the budibase/budibase image

      - name: Start old Budibase version
        id: start-old
        run: |
          # Start container with dynamic port mapping
          docker run -d \
            --name budibase \
            -P \
            -e INTERNAL_API_KEY=${{ env.INTERNAL_API_KEY }} \
            -e MULTI_TENANCY=0 \
            -e SELF_HOSTED=1 \
            -e REDIS_PASSWORD="budibase" \
            -e BB_ADMIN_USER_EMAIL="admin@example.com" \
            -e BB_ADMIN_USER_PASSWORD="admin123!" \
            -v budibase_data:/data \
            budibase/budibase:${{ matrix.version }}
          
          # Get the dynamically assigned port
          PORT=$(docker port budibase 80 | cut -d: -f2)
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "Budibase started on port $PORT"

      - name: Wait for old version to be ready
        run: |
          echo "Waiting for Budibase to be healthy..."
          timeout 180s bash -c 'until docker ps --filter "name=budibase" --filter "health=healthy" --format "table {{.Names}}\t{{.Status}}" | grep -q healthy; do
            echo "Waiting for container to be healthy..."
            docker ps --filter "name=budibase" --format "table {{.Names}}\t{{.Status}}"
            sleep 5
          done'
          echo "Budibase is healthy!"

      - name: Import test app
        id: import-app
        env:
          BUDIBASE_URL: http://localhost:${{ steps.start-old.outputs.port }}
          TEST_APP: ${{ matrix.app }}
        run: |
          cd packages/upgrade-tests
          # Import the specific test app for this matrix job
          APP_ID=$(node -e "
            const { BudibaseClient } = require('./dist/src/api/BudibaseClient');
            const { getAppPath } = require('./dist/src/utils/appHelpers');
            const client = new BudibaseClient();
            const appName = process.env.TEST_APP;
            (async () => {
              const appPath = getAppPath(appName);
              console.error('Importing app: ' + appName);
              const appId = await client.application.import(appPath, appName.replace(/-/g, ' '));
              
              if (appId) {
                console.error('App imported with ID: ' + appId);
                // Output just the app ID to stdout for capture
                console.log(appId);
              } else {
                console.error('Failed to import app - no ID returned');
                process.exit(1);
              }
            })().catch(error => {
              console.error('Import failed:', error.message || error);
              process.exit(1);
            });
          ")
          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
          echo "Captured app ID: $APP_ID"

      - name: Run pre-upgrade tests
        env:
          TEST_PHASE: pre-upgrade
          OLD_VERSION: ${{ matrix.version }}
          BUDIBASE_URL: http://localhost:${{ steps.start-old.outputs.port }}
          TEST_APP: ${{ matrix.app }}
          TEST_APP_ID: ${{ steps.import-app.outputs.app_id }}
          BUDIBASE_CONTAINER_NAME: budibase
        run: |
          cd packages/upgrade-tests
          yarn test

      - name: Stop old version
        run: |
          docker stop budibase
          docker rm budibase

      - name: Build current version
        run: |
          docker buildx build \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --load \
            -f hosting/single/Dockerfile \
            -t budibase:current \
            .
          
          # Move cache to avoid growing cache size indefinitely
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Start current version
        id: start-current
        run: |
          # Start container with dynamic port mapping
          docker run -d \
            --name budibase \
            -P \
            -e INTERNAL_API_KEY=${{ env.INTERNAL_API_KEY }} \
            -e MULTI_TENANCY=0 \
            -e SELF_HOSTED=1 \
            -e REDIS_PASSWORD="budibase" \
            -e BB_ADMIN_USER_EMAIL="admin@example.com" \
            -e BB_ADMIN_USER_PASSWORD="admin123!" \
            -v budibase_data:/data \
            budibase:current
          
          # Get the dynamically assigned port
          PORT=$(docker port budibase 80 | cut -d: -f2)
          echo "port=$PORT" >> $GITHUB_OUTPUT
          echo "Upgraded Budibase started on port $PORT"

      - name: Wait for current version to be ready
        run: |
          echo "Waiting for upgraded Budibase to be healthy..."
          timeout 180s bash -c 'until docker ps --filter "name=budibase" --filter "health=healthy" --format "table {{.Names}}\t{{.Status}}" | grep -q healthy; do
            echo "Waiting for container to be healthy..."
            docker ps --filter "name=budibase" --format "table {{.Names}}\t{{.Status}}"
            sleep 5
          done'
          echo "Upgraded Budibase is healthy!"

      - name: Run post-upgrade tests
        env:
          TEST_PHASE: post-upgrade
          OLD_VERSION: ${{ matrix.version }}
          CURRENT_VERSION: current
          BUDIBASE_URL: http://localhost:${{ steps.start-current.outputs.port }}
          TEST_APP: ${{ matrix.app }}
          TEST_APP_ID: ${{ steps.import-app.outputs.app_id }}
          BUDIBASE_CONTAINER_NAME: budibase
        run: |
          cd packages/upgrade-tests
          yarn test

      - name: Cleanup
        if: always()
        run: |
          docker stop budibase || true
          docker rm budibase || true
          docker volume rm budibase_data || true

  test-no-apps:
    needs: get-test-config
    if: needs.get-test-config.outputs.apps == '["no-apps"]'
    runs-on: ubuntu-latest
    steps:
      - name: No test apps found
        run: |
          echo "⚠️ No test apps found in fixtures directory"
          echo "Please add .tar.gz app exports to packages/upgrade-tests/src/fixtures/"
          exit 1

  report:
    needs: [get-test-config, test-upgrade, test-no-apps]
    if: always() && !cancelled()
    runs-on: ubuntu-latest
    steps:
      - name: Generate test summary
        run: |
          echo "## Upgrade Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Show what was tested
          echo "### Test Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Versions tested**: ${{ needs.get-test-config.outputs.versions }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Apps tested**: ${{ needs.get-test-config.outputs.apps }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Show results
          echo "### Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.test-upgrade.result }}" == "success" ]; then
            echo "✅ All upgrade tests passed!" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.test-upgrade.result }}" == "skipped" ]; then
            echo "⚠️ No tests were run (no apps found)" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Some upgrade tests failed" >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Report results
        run: |
          if [ "${{ needs.test-no-apps.result }}" == "success" ] || [ "${{ needs.test-no-apps.result }}" == "skipped" ]; then
            if [ "${{ needs.test-upgrade.result }}" == "success" ] || [ "${{ needs.test-upgrade.result }}" == "skipped" ]; then
              echo "✅ All upgrade tests passed!"
            else
              echo "❌ Some upgrade tests failed"
              exit 1
            fi
          else
            echo "⚠️ No test apps were found to test"
            exit 1
          fi
